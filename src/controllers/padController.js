const Pad = require('../models/Pad');
const { validatePadContent } = require('../services/validationService');

class PadController {
  async createPad(req, res) {
    try {
      const { title, content, encrypted, encryptionMeta, attachments = [] } = req.body;

      if (!title || !title.trim()) {
        return res.status(400).json({ message: 'Pad name is required' });
      }

      // Check if pad name already exists
      const existingPad = await Pad.findOne({
        title: { $regex: new RegExp(`^${title}$`, 'i') }
      });

      if (existingPad) {
        return res.status(409).json({ message: 'A pad with this name already exists. Please choose a different name.' });
      }

      // Validate content
      const validation = validatePadContent(content);
      if (!validation.valid) {
        return res.status(400).json({ message: validation.message });
      }

      // Create new pad document (slug will be auto-generated by pre-save hook)
      const newPad = new Pad({
        title,
        encrypted_blob: content,
        encrypted: encrypted || false,
        encryptionMeta: encrypted ? encryptionMeta : undefined,
        attachments: attachments.map(att => ({
          ...att,
          uploaded_at: new Date()
        }))
      });

      await newPad.save();

      // Return pad in the format frontend expects
      const responsePad = {
        id: newPad.slug,
        title: newPad.title,
        encrypted_blob: newPad.encrypted_blob,
        encrypted: newPad.encrypted,
        encryptionMeta: newPad.encryptionMeta,
        attachments: newPad.attachments || [],
        metadata: {
          created_at: newPad.metadata.created_at,
          updated_at: newPad.metadata.updated_at,
        },
      };

      res.status(201).json({ message: 'Pad created successfully', pad: responsePad });
    } catch (error) {
      res.status(500).json({ message: 'Error creating pad', error: error.message });
    }
  }

  async getPad(req, res) {
    try {
      const { id } = req.params;

      // Find by slug or by title (case-insensitive)
      const pad = await Pad.findOne({
        $or: [
          { slug: id.toLowerCase() },
          { title: { $regex: new RegExp(`^${id}$`, 'i') } }
        ]
      });

      if (pad) {
        const responsePad = {
          id: pad.slug,
          title: pad.title,
          encrypted_blob: pad.encrypted_blob,
          encrypted: pad.encrypted,
          encryptionMeta: pad.encryptionMeta,
          attachments: pad.attachments || [],
          metadata: {
            created_at: pad.metadata.created_at,
            updated_at: pad.metadata.updated_at,
          },
        };
        res.status(200).json(responsePad);
      } else {
        res.status(404).json({ message: 'Pad not found. Make sure you have the correct pad name.' });
      }
    } catch (error) {
      res.status(500).json({ message: 'Error retrieving pad', error: error.message });
    }
  }

  async updatePad(req, res) {
    try {
      const { id } = req.params;
      const { title, content, encryptionMeta, attachments } = req.body;

      // Validate content
      const validation = validatePadContent(content);
      if (!validation.valid) {
        return res.status(400).json({ message: validation.message });
      }

      // Find pad by slug or title
      const pad = await Pad.findOne({
        $or: [
          { slug: id.toLowerCase() },
          { title: { $regex: new RegExp(`^${id}$`, 'i') } }
        ]
      });

      if (pad) {
        pad.title = title || pad.title;
        pad.encrypted_blob = content;

        // Update encryption metadata if provided
        if (encryptionMeta !== undefined) {
          pad.encryptionMeta = encryptionMeta;
        }

        // Update attachments if provided
        if (attachments !== undefined) {
          pad.attachments = attachments.map(att => ({
            ...att,
            uploaded_at: att.uploaded_at || new Date()
          }));
        }

        await pad.save();

        const responsePad = {
          id: pad.slug,
          title: pad.title,
          encrypted_blob: pad.encrypted_blob,
          encrypted: pad.encrypted,
          encryptionMeta: pad.encryptionMeta,
          attachments: pad.attachments || [],
          metadata: {
            created_at: pad.metadata.created_at,
            updated_at: pad.metadata.updated_at,
          },
        };

        res.status(200).json({ message: 'Pad updated successfully', pad: responsePad });
      } else {
        res.status(404).json({ message: 'Pad not found' });
      }
    } catch (error) {
      res.status(500).json({ message: 'Error updating pad', error: error.message });
    }
  }

  async listPads(req, res) {
    try {
      const { search } = req.query;
      let query = {};

      // Filter by search term if provided
      if (search) {
        query = {
          title: { $regex: search, $options: 'i' }
        };
      }

      const pads = await Pad.find(query).sort({ 'metadata.updated_at': -1 });

      // Transform to match frontend format
      const responsePads = pads.map(pad => ({
        id: pad.slug,
        title: pad.title,
        encrypted_blob: pad.encrypted_blob,
        encrypted: pad.encrypted,
        metadata: {
          created_at: pad.metadata.created_at,
          updated_at: pad.metadata.updated_at,
        },
      }));

      res.status(200).json(responsePads);
    } catch (error) {
      res.status(500).json({ message: 'Error retrieving pads', error: error.message });
    }
  }
}

module.exports = PadController;